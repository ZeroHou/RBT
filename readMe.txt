实现简单的红黑树(RBT)
在实现二叉搜索树(AVL)的基础上增加红黑平衡旋转

性质：
1、根节点是黑色
2、插入节点是红的
3、红色节点的子节点是黑的
4、从任一节点到其每个叶子的所有路径都包含相同数目的黑色节点

结构体Node：左结点left、右结点right、数据data、颜色col
类RBT：根结点root

主要功能有：规则判断（红黑平衡旋转）、添加、删除、查询、遍历(前序遍历、中序遍历、后序遍历、层序遍历、深度优先搜索、广度优先搜索)、高度计算

时间复杂度：
1、规则判断（红黑平衡旋转）
比较左右子树红黑个数，时间复杂度为O(1)
2、添加
时间复杂度为O(logn)，最多两次单旋转（同一个地方）
3、删除
时间复杂度为O(logn)，最多三次单旋转（同一个地方）

简单描述一下二叉搜索树的删除过程，可以分为以下四种情况
a) 要删除的节点没有左右孩子
b) 要删除的节点只有左孩子（用左子结点代替）
c) 要删除的节点只有右孩子（用右子结点代替）
d) 要删除的节点有左右孩子（用后继结点代替）

我这里不直接用后继结点替代被删除结点，而是根据左右两颗子树高度，选择前继结点或者后继结点
a) 要删除的节点没有左右孩子
b) 要删除的节点有孩子(根据左右两颗子树高度，选择前继结点或者后继结点)

4、查询
时间复杂度为O(logn)
5、遍历
遍历全结点，时间复杂度为O(n)
6、高度计算
因为AVL树维护了结点高度，只需返回根结点高度，时间复杂度为O(1)

总结：
1、二叉树算法的核心是递归，实现二叉树的任何功能都可通过递归实现
2、前序遍历是dfs的一种
3、BFS就是层序遍历，可以用队列的特点来实现
4、中序遍历是二叉搜索树结点从小到大排序
5、高度计算可以用前序遍历来实现
6、递归处理每个分支的一半，跟二分法类似，属于减治法或者分治法，用分治法的主定理来算T(n)=aT(n/b)+f(n)，f(n)∈O(n^d)，这里a=1，b=2，d=0，a=b^d，因此T(n)∈O(n^d*logn)=O(logn)
7、AVL树是高度平衡，插入删除性能低，搜索性能高，红黑树搜索性能相对较低，插入删除性能高。若搜索次数远远大于插入删除，应选择AVL树，若搜索次数和插入删除次数差不多，则选择红黑树